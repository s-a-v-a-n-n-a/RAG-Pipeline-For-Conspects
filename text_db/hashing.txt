 Введение 
Существует два основных вида хеш-таблиц: с цепочками и открытой адресацией. Хеш-таблица содержит некоторый массив H, элементы которого есть пары (хеш-таблица с открытой адресацией) или списки пар (хеш-таблица с цепочками).

Выполнение операции в хеш-таблице начинается с вычисления хеш-функции от ключа. Хеш-код i = h(key) играет роль индекса в массиве H, а зная индекс, мы можем выполнить требующуюся операцию (добавление, удаление или поиск).

Количество коллизий зависит от хеш-функции; чем лучше используемая хеш-функция, тем меньше вероятность их возникновения. 

Способ разрешения коллизий — важная составляющая любой хеш-таблицы.

Полностью избежать коллизий для произвольных данных невозможно в принципе, и хорошая хеш-функция в состоянии только минимизировать их количество. Но, в некоторых специальных случаях их удаётся избежать. Если все ключи элементов известны заранее, либо меняются очень редко, то можно подобрать хеш-функцию, с помощью которой, все ключи будут распределены по хеш-таблице без коллизий. Это хеш-таблицы с прямой адресацией; в них все операции, такие как: поиск, вставка и удаление работают за O(1).

Если мы поделим число хранимых элементов на размер массива H (число возможных значений хеш-функции), то узнаем коэффициент заполнения хеш-таблицы (англ. load factor). От этого параметра зависит среднее время выполнения операций.

 Хеширование 
Хеширование (англ. hashing)  класс методов поиска, идея которого состоит в вычислении хеш-кода, однозначно определяемого элементом с помощью хеш-функции, и использовании его, как основы для поиска (индексирование в памяти по хеш-коду выполняется за O(1)). В общем случае, однозначного соответствия между исходными данными и хеш-кодом нет в силу того, что количество значений хеш-функций меньше, чем вариантов исходных данных, поэтому существуют элементы, имеющие одинаковые хеш-коды — так называемые коллизии, но если два элемента имеют разный хеш-код, то они гарантированно 
различаются. Вероятность возникновения коллизий играет немаловажную роль в оценке качества хеш-функций. Для того чтобы коллизии не замедляли работу с таблицей существуют методы для борьбы с ними.

 Виды хеширования 
 По способу хранения:
Статическое  фиксированное количество элементов. Один раз заполняем хеш-таблицу и осуществляем только проверку на наличие в ней нужных элементов,

Динамическое  добавляем, удаляем и смотрим на наличие нужных элементов.
 По виду хеш-функции:
Детерминированная хеш-функция,

Случайная хеш-функция.

 Свойства хеш-таблицы 

На поиск элемента в хеш-таблице в худшем случае, может потребоваться столько же времени, как и в списке, а именно \Theta(n), но на практике хеширование более эффективно. При некоторых разумных допущениях математическое ожидание времени поиска элемента в хеш-таблице составляет O(1). А все операции (поиск, вставка и удаление элементов) в среднем выполняются за время O(1).
При этом не гарантируется, что время выполнения отдельной операции мало́, так как при достижении некоторого значения коэффициента заполнения необходимо перехешировать таблицу: увеличить размер массива H и заново добавить в новую хеш-таблицу все пары.

Хеширование в современных языках программирования

Почти во всех современных языках присутствуют классы, реализующие хеширование. Рассмотрим некоторые из них.
Java
HashMap  HashMap  Java Platform SE 7  реализация интерфейса ассоциативного массива с использованием хеш-таблицы,
HashSet HashSet  Java Platform SE 7   реализация интерфейса множества с использованием хеш-таблицы,
LinkedHashMap LinkedHashMap  Java Platform SE 7  потомок класса HashMap. Позволяет просматривать значения в том порядке, в котором они были добавлены.
C++
unordered_map unordered_map  cplusplus.com  реализация интерфейса ассоциативного массива с использованием хеш-таблицы,
unordered_set  unordered_set  cplusplus.com   реализация интерфейса множества с использованием хеш-таблицы.
Python (CPython)
dict dictobject.c  https://github.com/python/cpython  реализация интерфейса ассоциативного массива с использованием хеш-таблицы,
set setobject.c  https://hg.python.org    реализация интерфейса множества с использованием хеш-таблицы.

 Примечания 

 Источники информации
 Томас Кормен, Чарльз Лейзерсон, Рональд Ривест, Клиффорд Штайн. «Алгоритмы. Построение и анализ»  «Вильямс», 2011 г.  1296 стр.  ISBN 978-5-8459-0857-5, 5-8459-0857-4, 0-07-013151-1
 Дональд Кнут. «Искусство программирования, том 3. Сортировка и поиск»  «Вильямс», 2007 г.  824 стр.  ISBN 0-201-89685-0
 Википедия  Хеш-таблица

Категория:Дискретная математика и алгоритмы
Категория:Хеширование
Категория:Структуры данных-----Разрешение коллизий (англ. collision resolution) в хеш-таблице, задача, решаемая несколькими способами: метод цепочек, открытая адресация и т.д. Очень важно сводить количество коллизий к минимуму, так как это увеличивает время работы с хеш-таблицами. 

 Разрешение коллизий с помощью цепочек 
thumb|380px|right|Разрешение коллизий при помощи цепочек.
Каждая ячейка i массива H содержит указатель на начало списка всех элементов, хеш-код которых равен i, либо указывает на их отсутствие. Коллизии приводят к тому, что появляются списки размером больше одного элемента.

В зависимости от того нужна ли нам уникальность значений операции вставки у нас будет работать за разное время. Если не важна, то мы используем список, время вставки в который будет в худшем случае равна O(1). Иначе мы проверяем есть ли в списке данный элемент, а потом в случае его отсутствия мы его добавляем. В таком случае вставка элемента в худшем случае будет выполнена за O(n)

Время работы поиска в наихудшем случае пропорционально длине списка, а если все n ключей захешировались в одну и ту же ячейку (создав список длиной n) время поиска будет равно \Theta(n) плюс время вычисления хеш-функции, что ничуть не лучше, чем использование связного списка для хранения всех n элементов.

Удаления элемента может быть выполнено за O(1), как и вставка, при использовании двухсвязного списка.

 Линейное разрешение коллизий 
thumb|380px|right|Пример хеш-таблицы с открытой адресацией и линейным пробированием.
Все элементы хранятся непосредственно в хеш-таблице, без использования связных списков. В отличие от хеширования с цепочками, при использовании этого метода может возникнуть ситуация, когда хеш-таблица окажется полностью заполненной, следовательно, будет невозможно добавлять в неё новые элементы. Так что при возникновении такой ситуации решением может быть динамическое увеличение размера хеш-таблицы, с одновременной её перестройкой.

 Стратегии поиска 

 Последовательный поиск 

При попытке добавить элемент в занятую ячейку i начинаем последовательно просматривать ячейки i+1, i+2, i+3 и так далее, пока не найдём свободную ячейку. В неё и запишем элемент.

400px|Последовательный поиск, частный случай линейного поиска.

 Линейный поиск 

Выбираем шаг q. При попытке добавить элемент в занятую ячейку i начинаем последовательно просматривать ячейки i+(1 \cdot q), i+(2 \cdot q), i+(3 \cdot q) и так далее, пока не найдём свободную ячейку. В неё и запишем элемент.
По сути последовательный поиск - частный случай линейного, где q=1.

400px|Линейный поиск с шагом q.

 Квадратичный поиск 

Шаг q не фиксирован, а изменяется квадратично: q = 1,4,9,16.... Соответственно при попытке добавить элемент в занятую ячейку i начинаем последовательно просматривать ячейки  i+1, i+4, i+9 и так далее, пока не найдём свободную ячейку.

400px|Квадратичный поиск.

 Проверка наличия элемента в таблице

Проверка осуществляется аналогично добавлению: мы проверяем ячейку i и другие, в соответствии с выбранной стратегией, пока не найдём искомый элемент или свободную ячейку.

При поиске элемента может получится так, что мы дойдём до конца таблицы. Обычно поиск продолжается, начиная с другого конца, пока мы не придём в ту ячейку, откуда начинался поиск.

 Проблемы данных стратегий 

Проблем две — крайне нетривиальное удаление элемента из таблицы и образование кластеров  — последовательностей занятых ячеек.

Кластеризация замедляет все операции с хеш-таблицей: при добавлении требуется перебирать всё больше элементов, при проверке тоже. Чем больше в таблице элементов, тем больше в ней кластеры и тем выше вероятность того, что добавляемый элемент попадёт в кластер.
Для защиты от кластеризации используется двойное хеширование и хеширование кукушки.

 Удаление элемента без пометок 

Рассуждение будет описывать случай с линейным поиском хеша. Будем при удалении элемента сдвигать всё последующие на q позиций назад. При этом:
 если в цепочке встречается элемент с другим хешем, то он должен остаться на своём месте (такая ситуация может возникнуть если оставшаяся часть цепочки была добавлена позже этого элемента)
 в цепочке не должно оставаться "дырок", тогда любой элемент с данным хешем будет доступен из начала цепи

Учитывая это будем действовать следующим образом: при поиске следующего элемента цепочки будем пропускать все ячейки с другим значением хеша, первый найденный элемент копировать в текущую ячейку, и затем рекурсивно его удалять. Если такой следующей ячейки нет, то текущий элемент можно просто удалить, сторонние цепочки при этом не разрушатся (чего нельзя сказать про случай квадратичного поиска).

 Псевдокод 

 function delete(Item i):
      j = i + q
      while table[j] == null or table[j].key != table[i].key
         if table[j] == null
            table[i] = null
            return
         j += q
      table[i] = table[j]
      delete(j)    

Хеш-таблицу считаем зацикленной

Вариант с зацикливанием мы не рассматриваем, поскольку если q взаимнопросто с размером хеш-таблицы, то для зацикливания в ней вообще не должно быть свободных позиций

Теперь докажем почему этот алгоритм работает. Собственно нам требуется сохранение трёх условий.
 В редактируемой цепи не остаётся дырок
Докажем по индукции. Если на данной итерации мы просто удаляем элемент (база), то после него ничего нет, всё верно. Если же нет, то вызванный в конце \mathrm{delete} (см. псевдокод) заметёт созданную дыру (скопированный элемент), и сам, по предположению, новых не создаст.
 Элементы, которые уже на своих местах, не должны быть сдвинуты.
Это учтено.
 В других цепочках не появятся дыры
Противное возможно только в том случае, если какой-то элемент был действительно удалён. Удаляем мы только последнюю ячейку в цепи, и если бы на её месте возникла дыра для сторонней цепочки, это бы означало что элемент, стоящий на q позиций назад, одновременно принадлежал нашей и другой цепочкам, что невозможно.

Двойное хеширование
Двойное хеширование (англ. double hashing)  метод борьбы с коллизиями, возникающими при открытой адресации, основанный на использовании двух хеш-функций для построения различных последовательностей исследования хеш-таблицы.

Принцип двойного хеширования
При двойном хешировании используются две независимые хеш-функции  h_1(k)  и  h_2(k) . Пусть  k   это наш ключ,  m   размер нашей таблицы, n \bmod m   остаток от деления  n  на  m , тогда сначала исследуется ячейка с адресом  h_1(k) , если она уже занята, то рассматривается  (h_1(k) +  h_2(k)) \bmod m , затем  (h_1(k) +  2 \cdot h_2(k)) \bmod m  и так далее. В общем случае идёт проверка последовательности ячеек  (h_1(k) +  i \cdot h_2(k)) \bmod m  где   i = (0, 1, \; ... \;,  m - 1) 

Таким образом, операции вставки, удаления и поиска в лучшем случае выполняются за O(1), в худшем  за O(m), что не отличается от обычного линейного разрешения коллизий.
Однако в среднем, при грамотном выборе хеш-функций, двойное хеширование будет выдавать лучшие результаты, за счёт того, что вероятность совпадения значений сразу двух независимых хеш-функций ниже, чем одной.

\forall x \neq y \; \exists h_1,h_2 : p(h_1(x)=h_1(y))> p((h_1(x)=h_1(y)) \land (h_2(x)=h_2(y)))

Выбор хеш-функций
 h_1  может быть обычной хеш-функцией. Однако чтобы последовательность исследования могла охватить всю таблицу,  h_2  должна возвращать значения:
не равные  0 
независимые  от  h_1 
взаимно простые с величиной хеш-таблицы

Есть два удобных способа это сделать. Первый состоит в том, что в качестве размера таблицы используется простое число, а  h_2  возвращает натуральные числа, меньшие  m . Второй  размер таблицы является степенью двойки, а  h_2  возвращает нечетные значения.

Например, если размер таблицы равен  m , то в качестве  h_2  можно использовать функцию вида  h_2(k) = k \bmod (m-1) + 1 

thumb|right|Вставка при двойном хешировании

Пример

Показана хеш-таблица размером 13 ячеек, в которой используются вспомогательные функции:

 h(k,i) = (h_1(k) + i \cdot h_2(k)) \bmod 13 

 h_1(k) = k \bmod 13 

 h_2(k) = 1 + k \bmod 11 

Мы хотим вставить ключ 14. Изначально  i = 0 . Тогда  h(14,0) = (h_1(14) + 0\cdot h_2(14)) \bmod 13 = 1 . Но ячейка с индексом 1 занята, поэтому увеличиваем  i  на 1 и пересчитываем значение хеш-функции. Делаем так, пока не дойдем до пустой ячейки. При  i = 2  получаем  h(14,2) = (h_1(14) + 2\cdot h_2(14)) \bmod 13 = 9 . Ячейка с номером 9 свободна, значит записываем туда наш ключ.

Таким образом, основная особенность двойного хеширования состоит в том, что при различных  k  пара  (h_1(k),h_2(k))  дает различные последовательности ячеек для исследования.

Простая реализация
Пусть у нас есть некоторый объект  item , в котором определено поле  key , от которого можно вычислить хеш-функции  h_1(key) и  h_2(key) 

Так же у нас есть таблица  table  величиной  m , состоящая из объектов типа  item .

Вставка
 function add(Item item):
      x = h1(item.key)
      y = h2(item.key)
      for (i = 0..m)    	
         if table[x] == null
            table[x] = item
            return      
         x = (x + y) mod m   
      table.resize()<span style="color:Green">// ошибка, требуется увеличить размер таблицы

Поиск
 Item search(Item key):
      x = h1(key)
      y = h2(key)
      for (i = 0..m)
         if table[x] != null
            if table[x].key == key
               return table[x]
         else
            return null
         x = (x + y) mod m   
      return null

Реализация с удалением
Чтобы наша хеш-таблица поддерживала удаление, требуется добавить массив deleted типов bool, равный по величине массиву table. Теперь при удалении мы просто будем помечать наш объект как удалённый, а при добавлении как не удалённый и замещать новым добавляемым объектом. При поиске, помимо равенства ключей, мы смотрим, удалён ли элемент, если да, то идём дальше.

Вставка
 function add(Item item):
      x = h1(item.key)
      y = h2(item.key)
      for (i = 0..m)   	
         if table[x] == null or deleted[x]
            table[x] = item
            deleted[x] = false
            return      
         x = (x + y) mod m   
      table.resize()<span style="color:Green">// ошибка, требуется увеличить размер таблицы
Поиск
 Item search(Item key):
      x = h1(key)
      y = h2(key)
      for (i = 0..m) 
         if table[x] != null
            if table[x].key == key and !deleted[x]
               return table[x]
         else
            return null
         x = (x + y) mod m   
      return null

Удаление
 function remove(Item key):
      x = h1(key)
      y = h2(key)
      for (i = 0..m)
         if table[x] != null
            if table[x].key == key
               deleted[x] = true
         else 
            return
         x = (x + y) mod m

Альтернативная реализация метода цепочек
В Java 8 для разрешения коллизий используется модифицированный метод цепочек. Суть его заключается в том, что когда количество элементов в корзине превышает определенное значение, данная корзина переходит от использования связного списка к использованию сбалансированного дерева. Но данный метод имеет смысл лишь тогда, когда на элементах хеш-таблицы задан линейный порядок. То есть при использовании данныx типа \mathbf{int} или \mathbf{double} имеет смысл переходить к дереву поиска, а при использовании каких-нибудь ссылок на объекты не имеет, так как они не реализуют нужный интерфейс. Такой подход позволяет улучшить производительность с O(n) до O(\log(n)). Данный способ используется в таких коллекциях как HashMap, LinkedHashMap и ConcurrentHashMap.

500px|Хеширование в Java 8.

См. также
 Хеширование
 Хеширование кукушки
 Идеальное хеширование

 Источники информации 
 Бакнелл Дж. М. «Фундаментальные алгоритмы и структуры данных в Delphi», 2003
 Кормен, Томас Х., Лейзерсон, Чарльз И., Ривест, Рональд Л., Штайн Клиффорд «Алгоритмы: построение и анализ», 2-е издание. Пер. с англ. — М.:Издательский дом "Вильямс", 2010.— Парал. тит. англ. — ISBN 978-5-8459-0857-5 (рус.)
 Дональд Кнут. «Искусство программирования, том 3. Сортировка и поиск»  «Вильямс», 2007 г. ISBN 0-201-89685-0
 Седжвик Р. «Фундаментальные алгоритмы на C. Части 1-4. Анализ. Структуры данных. Сортировка. Поиск», 2003
 Handle Frequent HashMap Collisions with Balanced Trees
 Wikipedia  Double_hashing
 Разрешение коллизий
 Пример хеш таблицы
 Пример хеш таблицы с двойным хешированием

Категория: Дискретная математика и алгоритмы
Категория: Хеширование
Категория: Структуры данных-----thumb|Пример хеширования кукушки. Стрелки показывают второе возможное место элементов. Если нам надо будет вставить новый элемент на место А, то мы поместим А в его вторую ячейку, занятую В, а В переместим в его вторую ячейку, которая сейчас свободна. А вот помещение нового элемента на место Н не получится: так как Н — часть цикла, добавленный элемент будет вытеснен после прохода по циклу.

Хеширование кукушки(англ. Cuckoo hashing)  один из способов борьбы с коллизиями при создании хеш-таблицы.

Алгоритм

Основная идея хеширования кукушки — использование двух хеш-функций вместо одной (далее h_1(x) и h_2(x)). Также есть вариант алгоритма, в котором используются две хеш-таблицы, и первая хеш-функция указывает на ячейку из первой таблицы, а вторая — из второй. Рассмотрим алгоритмы функций add(x), remove(x) и contains(x).

Выберем 2 хэш-функции h_1(x) и h_2(x) (из  универсального семейства хэш-функций).

Add 
Добавляет элемент с ключом x в хэш-таблицу

 Если одна из ячеек с индексами h_1(x) или h_2(x) свободна, кладем в нее элемент. 
 Иначе произвольно выбираем одну из этих ячеек, запоминаем элемент, который там находится, помещаем туда новый.
 Смотрим в ячейку, на которую указывает другая хеш-функция от элемента, который запомнили, если она свободна, помещаем его в нее. 
 Иначе запоминаем элемент из этой ячейки, кладем туда старый. Проверяем, не зациклились ли мы.
 Если не зациклились, то продолжаем данную процедуру поиска свободного места пока не найдем свободное место или зациклимся.
 Иначе выбираем 2 новые хеш-функции и перехешируем все добавленные элементы.
 Также после добавления нужно увеличить размер таблицы в случае если она заполнена.

Remove
Удаляет элемент с ключом x из хэш-таблицы.

 Смотрим ячейки с индексами h_1(x) и h_2(x).
 Если в одной из них есть искомый элемент, просто помечаем эту ячейку как свободную.

Contains
Проверяет на наличие элемента x в хэш-таблице

 Смотрим ячейки с индексами h_1(x) и h_2(x).
 Если в одной из них есть искомый элемент, возвращаем true.
 Иначе возвращаем false.

 Зацикливание 

Зацикливание может возникнуть при добавлении элемента. Пусть мы добавляем элемент x. И обе ячейки h_1(x) и h_2(x) заняты. Элемент x положили изначально в ячейку h_i(x). Если в ходе перемещений элементов в таблице на очередном шаге мы опять хотим переместить элемент x в ячейку h_i(x), чтобы в ячейку h_j(x) ~(i \ne j)  мы смогли поместить какой-то y (это может произойти, если в ходе перемещений элемент x был перемещен в ячейку h_j(x)), то произошло зацикливание.

Например, зацикливание возникнет, если добавить в хэш-таблицу 3 элемента x,y,z у которых h_1(x)=h_1(y)=h_1(z)  и h_2(x)=h_2(y)=h_2(z) .

Одним из способов решения проблемы зацикливания является смена хэш-функции, что было доказано Джоном Трампомhttps://eprint.iacr.org/2014/059.pdf

Время работы алгоритма

Удаление и проверка происходят за O(1) (что является основной особенностью данного типа хеширования), добавление в среднем происходит за O(1). Первые два утверждения очевидны: требуется проверить всего лишь 2 ячейки таблицы. 

Таким образом хеширование кукушки является одним из самых быстрых способов хеширования.

Плюсы и минусы алгоритма

Есть другие алгоритмы, которые используют несколько хеш-функций, в частности фильтр Блума, эффективная по памяти структура данных для нечётких множеств. Альтернативная структура данных для задач с теми же нечёткими множествами, основанная на кукушкином хешировании, называемая кукушкиным фильтром, использует даже меньшую память и (в отличие от классических фильтров Блума) позволяет удаление элемента, не только вставку и проверку существования. Однако теоретический анализ этих методов проведён существенно слабее, чем анализ фильтров БлумаBin Fan, Michael Kaminsky, David Andersen Cuckoo Filter: Better Than Bloom // ;login:. — USENIX, 2013. — Т. 38, вып. 4. — С. 36–40..

Исследования, проведённые Жуковским, Хеманом и БонзомMarcin Zukowski, Sandor Heman, Peter Boncz Architecture-Conscious Hashing. — Proceedings of the International Workshop on Data Management on New Hardware (DaMoN), 2006., показали, что кукушкино хеширование существенно быстрее метода цепочек для малых хеш-таблиц, находящихся в кэше современных процессоров. Кеннет РоссKenneth Ross Efficient Hash Probes on Modern Processors. — IBM Research Report RC24100, 2006. показал блочную версию кукушкиного хеширования (блок содержит более одного ключа), который работает быстрее обычных методов для больших хеш-таблиц в случае высокого коэффициента загрузки. Скорость работы блочной версии кукушкиной хеш-таблицы позднее исследовал Аскитис по сравнению с другими схемами хэширования.

Обзор МутцемахераM. Mitzenmacher. Proceedings of of the 17th Annual European Symposium on Algorithms (ESA). — 2009. представляет открытые проблемы, связанные с кукушкиным хешированием.

Самый большой минуc  потраченная память. Чтобы гарантировать O(n) по времени, нужно чтобы пары ключ/значение занимали не более 50\% памяти, потому что вытеснение старых элементов становится трудоемким. Также, добавление каждой новой хеш-функции значительно увеличивает среднюю скорость заполнения таблицы.

См. также
 Хеш-таблица
 Разрешение коллизий
 Идеальное хеширование

Примечания

Источники информации
 Wikipedia — Cuckoo hashing
 Cuckoo hashing — Pagh, Rasmus; Rodler, Flemming Friche (2001) (PDF, PS)

 Примеры 
 Concurrent high-performance Cuckoo hashtable written in C++
 Cuckoo hash map written in C++
 Static cuckoo hashtable generator for C/C++
 Generic Cuckoo hashmap in Java
 Cuckoo hash table written in Haskell
 Cuckoo hashing for Go

Категория: Алгоритмы и структуры данных
Категория: Хеширование----- Основная идея 
Идеальное хеширование используется в задачах со статическим множеством ключей (т.е. после того, как все ключи сохранены в таблице, их множество никогда не изменяется) для обеспечения хорошей асимптотики даже в худшем случае. При этом мы можем дополнительно хотеть, чтобы размер таблицы зависел от количества ключей линейно.

В таком хешировании для доступа к данным потребуется лишь вычисление хеш-функций (одной или нескольких), что делает данный подход наибыстрейшим для доступа к статическим данным. Данная технология применяется в различных словарях и базах данных, в алгоритмах со статической (известной заранее) информацией.

Будем использовать двухуровневую схему хеширования с универсальным хешированием на каждом уровне.
 Первый уровень 
Используется тот же принцип, что и в случае хеширования с цепочками: n ключей хешируются в m ячеек с использованием хеш-функции h(k) = ((a\cdot k+b) \bmod p) \bmod m, случайно выбранной из  семейства универсальных хеш-функций H_{p,m}, где p — простое число, превышающее m.

 Второй уровень 
На данном уровне вместо создания списка ключей будем использовать вторичную хеш-таблицу S_j, хранящую все ключи, хешированные функцией h в ячейку j, со своей функцией h_j(k)=((a_j\cdot k + b_j) \bmod p) \bmod m_j, выбранной из множества H_{p,m_j}. Путем точного выбора хеш-функции h_j мы можем гарантировать отсутствие коллизий на этом уровне. Для этого требуется, чтобы размер m_j хеш-таблицы S_j был равен квадрату числа n_j ключей, хешированных функцией h в ячейку j. 

Несмотря на квадратичную зависимость, ниже будет показано, что при корректном выборе хеш-функции первого уровня количество требуемой для хеш-таблицы памяти будет O(n).

 Теоретическое обоснование 

Это является очень хорошим результатом, если хотя бы вспомнить на примере  парадокса дней рождения о том, что вероятность коллизий растет крайне быстро по сравнению с размером хеш-таблицы.

Теперь выведем 2 следствия из этой теоремы.

См. также
 Хеширование
 Хеширование кукушки
 Разрешение коллизий

Источники информации
 Т. Кормен. «Алгоритмы. Построение и анализ» второе издание, Глава 11.5, стр. 308
 Д.Э. Кнут. «Искусство программирования: Сортировка и поиск" Том 3, Глава 6.4, стр. 563
 Wikipedia — Perfect hash function
 Universal and Perfect Hashing
 Универсальное хэширование. Идеальное хэширование

Категория:Дискретная математика и алгоритмы 
Категория:Хеширование-----При добавлении в хеш-таблицу большого количества элементов могут возникнуть ухудшения в ее работе. Обработка любого вызова будет занимать больше времени из-за увеличения размеров цепочек при хешировании на списках или кластеризации при хешировании с открытой адресацией, также, при хешировании с открытой адресацией может произойти переполнение таблицы. Для избежания таких ситуаций используется выбор новой хеш-функции и (или) хеш-таблица большего размера. Этот процесс называется перехеширование (rehashing).

Перехеширование при разных типах хеширования

При хешировании цепочками

При использовании хеширования цепочками , элементы с одинаковым результатом хеш-функции помещают в список. Так как операции \mathrm{add(x)}, \mathrm{contains(x)} и \mathrm{remove(x)} работают за O(l), где l  длина списка, то с некоторого момента выгодно увеличить размер хеш-таблицы, чтобы поддерживать амортизационную стоимость операции O(1).

Рассмотрим следующий алгоритм перехеширования: когда в хеш-таблицу добавлено \frac{4n}{3} элементов, где n  размер хеш-таблицы, создадим новую хеш-таблицу размера 2n, и последовательно переместим в нее все элементы первой таблицы. При этом, сменим хеш-функцию так, чтобы она выдавала значения [0..2n-1].

Найдем амортизационную стоимость добавления, после которого было сделано перехеширование, используя метод предоплаты. С момента последнего перехеширования было произведено не менее \frac{2n}{3} операций \mathrm{add(x)}, так как изначально в массиве находится \frac{2n}{3} элементов (или 0 в начале работы), а перехеширование происходит при наличии \frac{4n}{3} элементов. 

Для проведения перехеширования необходимо произвести \frac{4n}{3} операций \mathrm{add}(x), средняя стоимость которых составляет O(1) , потратить \frac{4n}{3} операций на проход хеш-таблицы, и \frac{4n}{3} операций на удаление предыдущей таблицы. В итоге, если мы увеличим стоимость каждой операции \mathrm{add}(x) на 6, то есть на O(1), операция перехеширования будет полностью предоплачена. Значит, амортизационная стоимость перехеширования при открытом типе хеш-таблицы равна O(1).

При хешировании с открытой адресацией
При использовании хеширования цепочками , операции  \mathrm{add}(x), \mathrm{contains}(x) и \mathrm{remove(x)} в худшем случае работают за O(k), где k  количество уже добавленных в таблицу элементов, поэтому перехеширование надо проводить при неполном заполнении хеш-таблицы.

Будем проводить перехеширование при заполнении таблицы на \frac{n}{2}, увеличивая размер таблицы в 2 раза. Аналогично случаю с открытым хешированием, для перехеширования необходимо будет потратить O(n) операций на обход таблицы, O(n)\cdot A элементарных операций на добавление элементов, где A  стоимость операции \mathrm{add(x)}, и O(n) операций на удаление таблицы. Так как A \geqslant 1, и между последовательными перехешированиями производится O(n) добавлений, то можно предоплатить перехеширование, увеличив стоимость операции \mathrm{add(x)} на O(1), и не изменив стоимость остальных операций.

См. также
 Амортизационный анализ
 Хеширование
 Открытое и закрытое хеширование

Источники информации
 Кормен, Томас Х., Лейзерсон, Чарльз И., Ривест, Рональд Л., Штайн Клиффорд «Алгоритмы: построение и анализ», 2-е издание. Пер. с англ. — М.:Издательский дом "Вильямс", 2010. — 1296 с.: ил. — Парал. тит. англ. — ISBN 978-5-8459-0857-5 (рус.)
 Дональд Кнут. «Искусство программирования, том 3. Сортировка и поиск»  «Вильямс», 2007 г. ISBN 0-201-89685-0

Категория: Дискретная математика и алгоритмы 
Категория: Амортизационный анализ
Категория: Хеширование-----__TOC__

Неформально вероятностное множество  это структура, позволяющая проверить принадлежность элемента множеству. Ответ может быть:

 элемент точно не принадлежит множеству,
 элемент возможно принадлежит множеству.
Фильтр Блума (англ. Bloom filter) — это реализация вероятностного множества, придуманная Бёртоном Блумом в 1970 году, позволяющая компактно хранить элементы и проверять принадлежность заданного элемента к множеству. При этом существует возможность получить ложноположительное срабатывание (элемента в множестве нет, но структура данных сообщает, что он есть), но не ложноотрицательное.

Фильтр Блума может использовать любой объём памяти, заранее заданный пользователем, причем чем он больше, тем меньше вероятность ложного срабатывания. Поддерживается операция добавления новых элементов в множество, но не удаления существующих (если только не используется модификация со счётчиками). С увеличением размера хранимого множества повышается вероятность ложного срабатывания.

 Описание структуры данных 

400px|thumb|Фильтр Блума с m = 9 и k = 3, хранящий множество из элементов A и B. Этот фильтр Блума может определить, что элемент C входит в множество, хотя он и не добавлен в него.

Фильтр Блума представляет собой битовый массив из m бит и k различных хеш-функций h_1 \dots h_k, равновероятно отображающих элементы исходного множества во множество  \big\{ 0, 1, \dots m - 1 \big\}, соответствующее номерам битов в массиве. 
Изначально, когда структура данных хранит пустое множество, все m бит обнулены.

Для добавления элемента  e  необходимо записать единицы на каждую из позиций h_1(e) \dots h_k(e) битового массива.

Чтобы проверить, что элемент e принадлежит множеству хранимых элементов, необходимо проверить состояние битов  h_1(e) \dots h_k(e) . Если хотя бы один из них равен нулю, элемент не принадлежит множеству. Если все они равны единице, то структура данных сообщает, что элемент принадлежит множеству. При этом может возникнуть две ситуации: либо элемент действительно принадлежит к множеству, либо все эти биты оказались установлены при добавлении других элементов, что и является источником ложных срабатываний в этой структуре данных.

По сравнению с хеш-таблицами, фильтр Блума может обходиться на несколько порядков меньшими объёмами памяти, жертвуя детерминизмом. Обычно он используется для уменьшения числа запросов к несуществующим данным в структуре данных с более дорогостоящим доступом (например, расположенной на жестком диске или в сетевой базе данных), то есть для «фильтрации» запросов к ней.

 Минимизация вероятности ложноположительного срабатывания 

Пусть размер битового массива  m , и заданы  k  хеш-функций, причем все хеш-функции выбираются случайным образом. Тогда вероятность, что в  j -ый бит не будет записана единица  i -ой хеш-функцией при вставке очередного элемента, равна:

p(h_i(x) \neq j) = 1 - \dfrac {1}{m} 

Так как для упрощения анализа мы предполагаем, что значения хеш-функций являются независимыми в совокупности случайными величинами, то вероятность, что  j -ый бит останется нулевым после добавления очередного элемента, равна:

p(h_i(x) \neq j для  \forall i \in \big\{ 1 \dots k \big\}) = (1 - \dfrac {1}{m})^k 

А вероятность того, что  j -ый бит будет равен нулю после вставки  n  различных элементов в изначально пустой фильтр:

(1 - \dfrac {1}{m})^{kn} 

В силу второго замечательного предела и достаточно большого  m  можем это записать как:

(1 - \dfrac {1}{m})^{kn} \approx e^{-kn/m}

Ложноположительное срабатывание происходит тогда, когда для несуществующего элемента все  k  бит окажутся ненулевыми, и фильтр Блума ответит, что он входит в число вставленных элементов.
Тогда вероятность такого события равна:

(1 - e^{-kn/m})^k

Для фиксированных  m  и  n , оптимальное число хеш-функций  k , минимизирующих вероятность ложноположительного срабатывания, равно:

k = \ln 2 \dfrac {m}{n} \approx 0.6931 \dfrac {m}{n}

 Свойства 

Фильтр Блума может хранить универсальное множество всех возможных элементов. При этом все ячейки битового массива будут содержать  1 .

При существовании двух фильтров Блума одинаковых размеров и с одинаковыми наборами хеш-функций, их объединение и пересечение может быть реализовано с помощью побитовых операций   \vee   и \wedge  .

 Примеры реализации фильтра Блума 
В ответ на запрос поиска есть вероятность получить положительный ответ, даже если этого элемента в данном множестве нет. Но если же ответ фильтра был отрицательным, запрашиваемого элемента точно нет. Чем больше размер этого множества, тем меньше вероятность получить некорректный ответ на запрос о наличии какого-либо элемента.

Google BigTableGoogle BigTable использует фильтры Блума, пример вероятностного множества, для уменьшения числа обращений к жесткому диску при проверке на существование заданной строки или столбца в таблице базы данных. Такой подход к нахождению необходимого элемента в базе данных значительно ускоряет сам процесс поиска и уменьшает количество обращений к жесткому диску,
компьютерные программы для проверки орфографии,
BitcoinWikipedia  Bitcoin использует фильтр Блума, чтобы ускорить синхронизацию с кошельком.

 Примечания 

 Источники информации
 Википедия  Фильтр Блума
 Wikipedia  Bloom filter
Demetrescu, Camil. «Experimental Algorithms»  «Springer», 2007 г.  108-121 стр.  ISBN 978-3-540-72844-3

Категория: Дискретная математика и алгоритмы 
Категория: Хеширование-----Определение

Качественная хеш-функция (англ. hash function) удовлетворяет (приближенно) условию простого равномерного хеширования: для каждого ключа, независимо от хеширования других ключей, равновероятно помещение его в любую из  m  ячеек. Но это условие обычно невозможно проверить, так как распределение вероятностей, с которыми поступают входные данные, как правило, неизвестно. К тому же, вставляемые ключи могут и не быть независимыми. Если наш противник будет умышленно выбирать ключи для хеширования при помощи конкретной хеш-функции, то при некоторых реализациях хеш-таблиц может получиться так, что все ключи будут записаны в одну и ту же ячейку таблицы, что приведет к среднему времени выборки  \Theta(n) . Таким образом,  любая фиксированная хеш-функция становится уязвимой. И единственный эффективный выход из данной ситуации  случайный выбор хеш-функции. Такой подход называется универсальным хешированием. Он гарантирует хорошую производительность в среднем, вне зависимости от данных, выбранных нашим противником.

Иными словами, при случайном выборе хеш-функции из  H  вероятность коллизии между различными ключами  k, l  не превышает вероятности совпадения двух случайным образом выбранных хеш-значений из множества  \{0, 1, 2, .. , m - 1\} , которая равна  \frac{1}{m} .

Построение универсального множества хеш-функций

 Попарная независимость 

Построение попарно независимого множества хеш-функций

Источники информации

 Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн Алгоритмы: построение и анализ — 2-е изд. — М.: «Вильямс», 2005. — с. 294. — ISBN 5-8459-0857-4

Категория: Дискретная математика и алгоритмыКатегория:Хеширование-----